---
title: "01_原理-事件循环"
description: "事件循环第一节课"
---
# 事件循环（event loop）
不会事件循环，根本不懂前端，事件循环是浏览器的核心原理，面试常考
- 计时器
- promise
- ajax
- node

等等都和事件循环有关
## 浏览器的进程模型

### 何为进程
<Note>程序运行需要有他自己专属的<b>内存空间</b>，可以把这块内存空间简单的理解为<b>进程</b></Note>
- 进程是程序运行的最小单位，一个进程可以包含多个线程
- 每个应用至少有一个进程（一块空间），进程之间相互独立，即使要通信，也需要双方同意
![进程](https://s2.loli.net/2023/11/13/8c7WE1O2D4NjoVf.webp)
### 何为线程
有了进程后，就可以运行程序的代码了
运行代码的【人】称之为【线程】
- 线程是程序运行的最小单位，一个进程至少有一个线程
<Note>所以在进程开启后会自动会创建一个线程来运行代码，主线程（主线程结束，程序就结束）</Note>
- 线程共享进程的内存空间，线程间通信更加方便
- 如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程
![线程](https://s2.loli.net/2023/11/13/W4gRhz3yqCUJ1o5.webp)
### 浏览器有哪些进程和线程
浏览器是一个多进程多线程的应用程序，内部工作极其复杂
为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程
- 浏览器主进程（浏览器）
    - 负责界面的展示：浏览器Ui：比如导航栏、标签页、前进后退按钮的样子等等
    - 用户交互：用户点击，鼠标滚轮等用户交互，浏览器监控
    - 子进程管理
    - 浏览器进程会启动多个线程处理不同任务
- 网络进程（Netword Service）
    - 负责页面的网络资源加载，如图片、视频等
- 渲染进程（一个标签页一个渲染进程）
    - 渲染进程启动后，会开启一个渲染主线程，主线程负责执行html，css，js代码
    - 每个标签页开启一个新的渲染进程（会导致内存过大,后续可能会更新（site-per-process）
![浏览器进程](https://s2.loli.net/2023/11/13/UMbl8pfADFSEihJ.webp)
<Note>可以在浏览器-任务管理器中看到当前所有进程</Note>
![任务管理器](https://s2.loli.net/2023/11/13/XgxzjEWFmci1Qsf.webp)
## 渲染主线程如何工作
渲染主线程是浏览器中最繁忙线程，任务如下
- 解析html，css，js代码，构建dom树和渲染树
- 计算样式（px像素计算）
- 布局和绘制
- 处理图层
- 每秒把页面画60次
- 执行全局js代码
- 执行事件处理函数
- 执行计时器的回调函数
....
<Note>为什么渲染进程不适用多个线程来处理这些事情？</Note>
要处理这么多的任务，主线程遇到了一个前所未有的难题：如果调度任务
比如：
    - 我正在执行一个JS函数，执行到一半的时候某个计时器触发，我需要立即去执行他的回调吗
        - 不用，排队
    - 我正在执行一个JS函数，执行到一半的时候用户点击了按钮，我需要立即去执行点击事件的回调吗
        - 不用，排队
    - 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个
        
解决办法：排队
- 渲染进程主线程会为每个任务创建一个任务队列，然后依次执行
![排队](https://s2.loli.net/2023/11/13/9vh6tqCRuGmNFY3.webp)
1.在最开始的时候，渲染主线程会进入一个无限循环
![无限循环](https://s2.loli.net/2023/11/13/6Xw4z2EpsViKNbt.webp)
    - 
2.每一次循环都会去查看消息队列中是否有任务
    - 如果有任务，就取出第一个任务执行，执行后进入下一次循环
    - 如果没有任务，进入休眠状态
3.其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。
    - 新任务会被添加到消息队列的尾部
    - 如果主线程是休眠状态，就会唤醒主线程，执行任务

<Tip>整个过程，称为事件循环(消息循环)</Tip>

## 若干解释
### 异步
代码在执行过程中，会遇到一些无法立即处理的任务：
    - 计时完成后需要立即执行的任务
        - setTimeout(func,3000)
        - setInterval
    - 网络通信完成后需要执行的任务：
        - XHR
        - Fetch
    - 用户操作后需要立即执行的任务：
        - addEventListener
如果让渲染主线程等待这些任务的时间达到，就会导致主线程长期处于阻塞状态，导致浏览器卡死
![执行](https://s2.loli.net/2023/11/14/TzNwIqhuHsWc1GY.webp)
<Note>所以，渲染主线程需要异步执行这些任务</Note>
![异步](https://s2.loli.net/2023/11/14/a4UNIzh79qbYt8n.webp)
比如如下代码，定时器任务将会一直等待
```js
    setTimeout(function(){
        console.log('定时器线程开始执行');
    },1000)

    for(;;){
        console.log('定时器线程等待执行');
    }
```
![代码案例](https://s2.loli.net/2023/11/14/WTO46ejFtbxMYKI.webp)

面试题：如何理解JS的异步
完美答案
![完美答案](https://s2.loli.net/2023/11/14/ngwBJry4DfiMvLo.webp)
